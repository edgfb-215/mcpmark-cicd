name: Issue Management Automation
on:
  issues:
    types: [opened, labeled]

jobs:
  issue-triage:
    runs-on: ubuntu-latest
    steps:
      - name: Run Issue Triage
        uses: actions/github-script@v7
        with:
          script: |
            const { github, context } = require('@actions/github');
            const issue = context.issue;
            const issueTitle = context.payload.issue.title.toLowerCase();
            const issueBody = context.payload.issue.body?.toLowerCase() || '';

            // Step 1: Create required labels if they don't exist
            const labelsToCreate = [
              // Category Labels
              { name: 'bug', color: 'd73a4a', description: 'Something isn\'t working' },
              { name: 'enhancement', color: 'a2eeef', description: 'New feature or request' },
              { name: 'epic', color: '0052cc', description: 'Large feature requiring multiple sub-tasks' },
              { name: 'maintenance', color: 'fef2c0', description: 'Maintenance and housekeeping tasks' },
              // Priority Labels
              { name: 'priority-critical', color: 'b60205', description: 'Critical priority issue' },
              { name: 'priority-high', color: 'd93f0b', description: 'High priority issue' },
              { name: 'priority-medium', color: 'fbca04', description: 'Medium priority issue' },
              { name: 'priority-low', color: '0e8a16', description: 'Low priority issue' },
              // Status Labels
              { name: 'needs-triage', color: 'b60205', description: 'Needs to be reviewed by maintainers' },
              { name: 'needs-review', color: '0052cc', description: 'Awaiting review from maintainers' },
              { name: 'first-time-contributor', color: '1d76db', description: 'Issue created by first-time contributor' }
            ];

            for (const label of labelsToCreate) {
              try {
                await github.rest.issues.getLabel({
                  owner: issue.owner,
                  repo: issue.repo,
                  name: label.name
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: issue.owner,
                    repo: issue.repo,
                    name: label.name,
                    color: label.color,
                    description: label.description
                  });
                }
              }
            }

            // Step 2: Add needs-triage label
            await github.rest.issues.addLabels({
              owner: issue.owner,
              repo: issue.repo,
              issue_number: issue.number,
              labels: ['needs-triage']
            });

            // Step 3: Assign category label based on title
            let categoryLabel = null;
            if (issueTitle.includes('bug')) {
              categoryLabel = 'bug';
            } else if (issueTitle.includes('epic')) {
              categoryLabel = 'epic';
            } else if (issueTitle.includes('maintenance')) {
              categoryLabel = 'maintenance';
            }

            if (categoryLabel) {
              await github.rest.issues.addLabels({
                owner: issue.owner,
                repo: issue.repo,
                issue_number: issue.number,
                labels: [categoryLabel]
              });
            }

            // Step 4: Assign priority label (highest priority wins)
            let priorityLabel = 'priority-medium'; // default
            const priorityKeywords = {
              'priority-critical': ['critical', 'urgent', 'production', 'outage'],
              'priority-high': ['important', 'high', 'blocking'],
              'priority-low': ['low', 'nice-to-have', 'minor']
            };

            // Check critical first
            if (priorityKeywords['priority-critical'].some(word => issueTitle.includes(word) || issueBody.includes(word))) {
              priorityLabel = 'priority-critical';
            }
            // Then high
            else if (priorityKeywords['priority-high'].some(word => issueTitle.includes(word) || issueBody.includes(word))) {
              priorityLabel = 'priority-high';
            }
            // Then low
            else if (priorityKeywords['priority-low'].some(word => issueTitle.includes(word) || issueBody.includes(word))) {
              priorityLabel = 'priority-low';
            }

            await github.rest.issues.addLabels({
              owner: issue.owner,
              repo: issue.repo,
              issue_number: issue.number,
              labels: [priorityLabel]
            });

  task-breakdown:
    runs-on: ubuntu-latest
    needs: issue-triage
    if: contains(github.event.issue.labels.*.name, 'epic')
    steps:
      - name: Create Epic Sub-Tasks
        uses: actions/github-script@v7
        with:
          script: |
            const { github, context } = require('@actions/github');
            const issue = context.issue;
            const parentIssueNumber = issue.number;
            const parentIssueTitle = context.payload.issue.title;

            // Sub-task details
            const subTasks = [
              { taskNumber: 1, name: 'Requirements Analysis' },
              { taskNumber: 2, name: 'Design and Architecture' },
              { taskNumber: 3, name: 'Implementation' },
              { taskNumber: 4, name: 'Testing and Documentation' }
            ];

            // Create sub-issues and collect their numbers
            const subIssueNumbers = [];
            for (const task of subTasks) {
              const subTaskTitle = `[SUBTASK] ${parentIssueTitle} - Task ${task.taskNumber}: ${task.name}`;
              const subTaskBody = `Related to #${parentIssueNumber}`;

              const subIssue = await github.rest.issues.create({
                owner: issue.owner,
                repo: issue.repo,
                title: subTaskTitle,
                body: subTaskBody,
                labels: ['enhancement', 'needs-review']
              });

              subIssueNumbers.push(subIssue.data.number);
            }

            // Update parent issue body with Epic Tasks checklist
            const parentIssueBody = context.payload.issue.body || '';
            const epicTasksSection = `\n\n## Epic Tasks\n${subIssueNumbers.map(num => `- [ ] #${num}`).join('\n')}`;
            const updatedBody = parentIssueBody + epicTasksSection;

            await github.rest.issues.update({
              owner: issue.owner,
              repo: issue.repo,
              issue_number: parentIssueNumber,
              body: updatedBody
            });

  auto-response:
    runs-on: ubuntu-latest
    needs: [issue-triage, task-breakdown]
    if: always() # Run even if task-breakdown is skipped (e.g., not an epic)
    steps:
      - name: Run Auto-Response
        uses: actions/github-script@v7
        with:
          script: |
            const { github, context } = require('@actions/github');
            const issue = context.issue;
            const issueAuthor = context.payload.issue.user.login;
            const issueLabels = context.payload.issue.labels.map(label => label.name);

            // Step 1: Check if this is the author's first issue in the repo
            const authorIssues = await github.rest.issues.listForRepo({
              owner: issue.owner,
              repo: issue.repo,
              author: issueAuthor,
              state: 'all'
            });

            const isFirstIssue = authorIssues.data.length === 1; // Only this issue
            if (isFirstIssue) {
              await github.rest.issues.addLabels({
                owner: issue.owner,
                repo: issue.repo,
                issue_number: issue.number,
                labels: ['first-time-contributor']
              });

              // Post welcome message
              await github.rest.issues.createComment({
                owner: issue.owner,
                repo: issue.repo,
                issue_number: issue.number,
                body: `Welcome @${issueAuthor}! This is your first issue in this repository. We appreciate your contribution and will review your issue shortly.`
              });
            }

            // Step 2: Post comment based on issue type
            let commentContent = '';
            if (issueLabels.includes('bug')) {
              commentContent = '### Bug Report Guidelines\nPlease ensure you have provided all necessary details in your bug report, including steps to reproduce, expected behavior, and environment information. This helps us resolve the issue more quickly.';
            } else if (issueLabels.includes('epic')) {
              commentContent = '### Feature Request Process\nThis epic has been broken down into sub-tasks. We will review the requirements and progress through the implementation stages as outlined in the sub-issues.';
            } else if (issueLabels.includes('maintenance')) {
              commentContent = '### Maintenance Guidelines\nThank you for submitting this maintenance task. We will review the tasks outlined and prioritize them accordingly.';
            }

            if (commentContent) {
              await github.rest.issues.createComment({
                owner: issue.owner,
                repo: issue.repo,
                issue_number: issue.number,
                body: commentContent
              });
            }

            // Step 3: Set milestone for high/critical priority
            if (issueLabels.includes('priority-high') || issueLabels.includes('priority-critical')) {
              // Check if milestone v1.0.0 exists
              let milestoneId = null;
              try {
                const milestones = await github.rest.issues.listMilestones({
                  owner: issue.owner,
                  repo: issue.repo,
                  state: 'all'
                });
                const v1Milestone = milestones.data.find(m => m.title === 'v1.0.0');
                if (v1Milestone) {
                  milestoneId = v1Milestone.number;
                } else {
                  // Create milestone if not exists
                  const newMilestone = await github.rest.issues.createMilestone({
                    owner: issue.owner,
                    repo: issue.repo,
                    title: 'v1.0.0',
                    description: 'Version 1.0.0 release milestone'
                  });
                  milestoneId = newMilestone.data.number;
                }
              } catch (error) {
                console.error('Error handling milestone:', error);
              }

              if (milestoneId) {
                await github.rest.issues.update({
                  owner: issue.owner,
                  repo: issue.repo,
                  issue_number: issue.number,
                  milestone: milestoneId
                });
              }
            }

            // Step 4: Update status from needs-triage to needs-review
            await github.rest.issues.removeLabel({
              owner: issue.owner,
              repo: issue.repo,
              issue_number: issue.number,
              name: 'needs-triage'
            });

            await github.rest.issues.addLabels({
              owner: issue.owner,
              repo: issue.repo,
              issue_number: issue.number,
              labels: ['needs-review']
            });